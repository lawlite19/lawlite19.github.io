<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://lawlite.cn">
  <title>高并发网络线程模型 | Lawlite的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="基础服务器端处理一次网络请求流程 获取请求的数据 客户端与服务器建立连接发出请求，服务器接受请求   构建响应数据 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成   返回数据 服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端">
<meta name="keywords" content="io">
<meta property="og:type" content="article">
<meta property="og:title" content="高并发网络线程模型">
<meta property="og:url" content="http://lawlite.cn/2022/08/27/高并发网络线程模型/index.html">
<meta property="og:site_name" content="Lawlite的博客">
<meta property="og:description" content="基础服务器端处理一次网络请求流程 获取请求的数据 客户端与服务器建立连接发出请求，服务器接受请求   构建响应数据 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成   返回数据 服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/1569484-20190320120750866-113550043.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/bio_时序.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/bio_流程.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/nio.png">
<meta property="og:image" content="http://lawlite.cn/Users/lawlite/Library/Application%20Support/typora-user-images/image-20220703155615706.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/image-20220619221532446.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/image-20220529225247909.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/epoll工作流程.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/epoll_et_lt.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/reactor.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/reactor_class.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/reactor_时序.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/image-20220712001415441.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/image-20220703160015365.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/image-20220703160033862.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/netty模型图.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/epoll_工作流程.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/信号量驱动_时序.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/aio_时序.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/proactor_class.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/proactor_时序png.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/IO模型比较.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/redis_1.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/redis_单线程.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/nginx_master_worker.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/mysql_线程框架.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/mysql_连接池和线程池.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/memcache网络模型.png">
<meta property="og:image" content="http://lawlite.cn/assets/blog_images/io_model/zookeeper.png">
<meta property="og:updated_time" content="2022-09-26T15:53:53.541Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高并发网络线程模型">
<meta name="twitter:description" content="基础服务器端处理一次网络请求流程 获取请求的数据 客户端与服务器建立连接发出请求，服务器接受请求   构建响应数据 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成   返回数据 服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端">
<meta name="twitter:image" content="http://lawlite.cn/assets/blog_images/io_model/1569484-20190320120750866-113550043.png">
  
    <link rel="alternative" href="/atom.xml" title="Lawlite的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" type="text/css" href="/./main.234bc0.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?aafd2cc62b94803248a1bee49dbc581f";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #279ADB"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/img/avatar.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">Lawlite</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
				<li><a href="/photos/">相册 &amp; 视频</a></li>
	        
				<li><a href="/留言板/">留言板</a></li>
	        
				<li><a href="http://lawlite.cn/archives/">归档</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/lawlite19" title="github"><i class="icon-github"></i></a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/lawlite.me" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #279ADB"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/img/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Lawlite</h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/lawlite19" title="github"><i class="icon-github"></i></a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/lawlite.me" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 20%"><a href="/">主页</a></li>
		        
					<li style="width: 20%"><a href="/tags/随笔/">随笔</a></li>
		        
					<li style="width: 20%"><a href="/photos/">相册 &amp; 视频</a></li>
		        
					<li style="width: 20%"><a href="/留言板/">留言板</a></li>
		        
					<li style="width: 20%"><a href="http://lawlite.cn/archives/">归档</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-高并发网络线程模型" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      高并发网络线程模型
    </h1>
  

		<!-- 显示阅读和评论数 -->
		
		<br/>
		<a class="cloud-tie-join-count" href="javascript:void(0);" style="color:gray;font-size:14px;">
		<span class="icon-sort"></span>
		<span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;">
            阅读数: <span id="busuanzi_value_page_pv"></span>次 &nbsp;&nbsp;
		</span>
		</a>
		<!-- 网易的评论数，这里先不使用
		<a class="cloud-tie-join-count" href="javascript:void(0);" style="color:#ef7522;font-size:14px;">
			<span class="icon-comment"></span>
			<span class="join-text" style="color:#ef7522;font-size:14px;">参与数:</span>
			<span class="join-count">0</span>人
		</a>  -->
		
		
        
        <a href="/2022/08/27/高并发网络线程模型/" class="archive-article-date">
  	<time datetime="2022-08-27T03:38:15.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2022-08-27</time>
</a>
        
      </header>
    
		<!-- 目录内容 -->
		
		    <p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none">
            <span class="btn-bg"></span>
            <span class="btn-text">文章导航</span>
            </p>
			<div id="toc-article" class="toc-article">
			    <span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">×</span>
				<strong class="toc-title">文章目录</strong>
	            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器端处理一次网络请求流程"><span class="toc-number">1.1.</span> <span class="toc-text">服务器端处理一次网络请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核缓冲区和用户进程缓冲区"><span class="toc-number">1.2.</span> <span class="toc-text">内核缓冲区和用户进程缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件描述符"><span class="toc-number">1.3.</span> <span class="toc-text">文件描述符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO模型"><span class="toc-number">2.</span> <span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步阻塞IO（BIO）"><span class="toc-number">2.1.</span> <span class="toc-text">同步阻塞IO（BIO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-number">2.1.1.</span> <span class="toc-text">说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞IO和非阻塞IO"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">阻塞IO和非阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步IO和异步IO"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">同步IO和异步IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序图"><span class="toc-number">2.1.2.</span> <span class="toc-text">时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO代码示例"><span class="toc-number">2.1.3.</span> <span class="toc-text">BIO代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步非阻塞IO（NIO）"><span class="toc-number">2.2.</span> <span class="toc-text">同步非阻塞IO（NIO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序图-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO代码示例"><span class="toc-number">2.2.3.</span> <span class="toc-text">NIO代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO多路复用"><span class="toc-number">2.3.</span> <span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序图-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO多路复用代码示例"><span class="toc-number">2.3.3.</span> <span class="toc-text">IO多路复用代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">2.3.4.</span> <span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三种对比"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">三种对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor设计模式"><span class="toc-number">2.3.5.</span> <span class="toc-text">Reactor设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor模式结构"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">Reactor模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor时序图"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">Reactor时序图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单线程"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主从多线程"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">主从多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#netty模型图"><span class="toc-number">2.3.5.5.1.</span> <span class="toc-text">netty模型图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作流程（Epoll为例）"><span class="toc-number">2.3.5.6.</span> <span class="toc-text">工作流程（Epoll为例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor优缺点"><span class="toc-number">2.3.5.7.</span> <span class="toc-text">Reactor优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#单线程Reactor代码示例"><span class="toc-number">2.3.5.7.1.</span> <span class="toc-text">单线程Reactor代码示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量驱动"><span class="toc-number">2.4.</span> <span class="toc-text">信号量驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序图-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点"><span class="toc-number">2.4.3.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步IO"><span class="toc-number">2.5.</span> <span class="toc-text">异步IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序图-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步IO代码示例"><span class="toc-number">2.5.3.</span> <span class="toc-text">异步IO代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proactor设计模式"><span class="toc-number">2.5.4.</span> <span class="toc-text">Proactor设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Proactor模式结构"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">Proactor模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proactor时序图"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">Proactor时序图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和Reactor差别"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">和Reactor差别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#主动和被动"><span class="toc-number">2.5.4.3.1.</span> <span class="toc-text">主动和被动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#实现"><span class="toc-number">2.5.4.3.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5种IO模型比较"><span class="toc-number">2.6.</span> <span class="toc-text">5种IO模型比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO模型使用的例子"><span class="toc-number">3.</span> <span class="toc-text">IO模型使用的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-6-0之前-gt-单线程Reactor"><span class="toc-number">3.1.</span> <span class="toc-text">Redis(6.0之前) => 单线程Reactor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx-gt-master-worker多进程模型"><span class="toc-number">3.2.</span> <span class="toc-text">Nginx => master-worker多进程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-gt-一个连接一个线程或线程池"><span class="toc-number">3.3.</span> <span class="toc-text">Mysql => 一个连接一个线程或线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memcache-》-单listener-固定worker线程"><span class="toc-number">3.4.</span> <span class="toc-text">Memcache =》 单listener+固定worker线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper"><span class="toc-number">3.5.</span> <span class="toc-text">Zookeeper</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li></ol>
           </div>
		   <script type="text/javascript">
			function showToc(){
				var toc_article = document.getElementById("toc-article");
				var show_toc_btn = document.getElementById("show-toc-btn");
				toc_article.setAttribute("style","display:block");
				show_toc_btn.setAttribute("style","display:none");
				};
			function showBtn(){
				var toc_article = document.getElementById("toc-article");
				var show_toc_btn = document.getElementById("show-toc-btn");
				toc_article.setAttribute("style","display:none");
				show_toc_btn.setAttribute("style","display:block");
				};
		   </script>
        		
		<!-- 目录内容结束 -->
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="服务器端处理一次网络请求流程"><a href="#服务器端处理一次网络请求流程" class="headerlink" title="服务器端处理一次网络请求流程"></a>服务器端处理一次网络请求流程</h2><ul>
<li>获取请求的数据<ul>
<li>客户端与服务器建立连接发出请求，服务器接受请求</li>
</ul>
</li>
<li>构建响应数据<ul>
<li>当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成</li>
</ul>
</li>
<li>返回数据<ul>
<li>服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/1569484-20190320120750866-113550043.png" alt="图片"></p>
<a id="more"></a>
<h2 id="内核缓冲区和用户进程缓冲区"><a href="#内核缓冲区和用户进程缓冲区" class="headerlink" title="内核缓冲区和用户进程缓冲区"></a>内核缓冲区和用户进程缓冲区</h2><ul>
<li><p>说明</p>
<blockquote>
<p>在 Linux 系统中，所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序是无法直接进行这样的操作的。但是可以通过内核提供的接口来完成这样的任务。</p>
<p>比如应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态，在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，然后往下继续执行</p>
</blockquote>
</li>
<li><p>用户进程的IO读写会用到底层的read、write两大系统调用</p>
<ul>
<li>read系统调用并不是直接从物理设备把数据读取到应用内存中，而是把数据从内核缓冲区复制到用户进程缓冲区。write也是类似。</li>
<li>使用缓冲区的好处就是等待缓冲区达到一定数量的时候，进行IO设备的中断处理，集中执行物理设备实际的IO操作</li>
</ul>
</li>
<li><p>Linux系统中，操作系统内核只有一个内核缓冲区，每个用户进程都有自己的独立缓冲区。</p>
</li>
<li><p>再以上图为例，Java客户端和服务端完成一次socket请求和相应的数据交换流程</p>
<ul>
<li>客户端发送请求：<ul>
<li>Java客户端通过write系统调用将数据复制到内核缓冲区，Linux将内核缓冲区的请求数据通过客户端机器的网卡发送出去。</li>
<li>在服务端请求数据会从接收网卡中的数据读取到服务端机器的内核缓冲区</li>
</ul>
</li>
<li>服务端获取请求：<ul>
<li>Java服务端通过read系统调用将内核缓冲区的数据读取到用户进程缓冲区进行处理</li>
</ul>
</li>
<li>服务器端处理请求<ul>
<li>具体的业务逻辑</li>
</ul>
</li>
<li>服务器端返回数据<ul>
<li>服务器端处理完请求，通过write系统调用将用户进程数据写入内核缓冲区</li>
</ul>
</li>
<li>发送给客户端<ul>
<li>Linux将内核缓冲区的数据写入到网卡，网卡通过底层的通信协议将数据发送给目标客户端</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><ul>
<li><p><strong>文件描述符（File descriptor）</strong>是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
</li>
<li><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</li>
</ul>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="同步阻塞IO（BIO）"><a href="#同步阻塞IO（BIO）" class="headerlink" title="同步阻塞IO（BIO）"></a>同步阻塞IO（BIO）</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h4><ul>
<li>阻塞IO是指需要内核IO操作彻底完成之后才返回到用户空间执行用户程序；</li>
<li>非阻塞IO是指用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间去执行后续的指令。</li>
</ul>
<h4 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h4><ul>
<li>同步IO是指用户程序是主动发起IO请求的一方，系统内核是被动接收的一方；</li>
<li>异步IO是指系统内核是主动发起IO请求的一方，用户程序是被动接收方。</li>
</ul>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><ul>
<li>用户进程A想要读socket1的数据，这时它发起系统调用，向kernel要数据，但是由于数据还没准备好，所以它发起读取请求后，就<strong>阻塞</strong>住了，直到数据准备好了，然后kernel把数据从socket1缓冲区拷贝到进程A的缓冲区后，才给进程A做出响应，然后进程A才能继续做后续操作。</li>
</ul>
<p><img src="/assets/blog_images/io_model/bio_时序.png" alt="图片"></p>
<h3 id="BIO代码示例"><a href="#BIO代码示例" class="headerlink" title="BIO代码示例"></a>BIO代码示例</h3><ul>
<li><p>Java中默认创建的socker都是阻塞IO模型</p>
</li>
<li><p>如下示例<code>serverSocket.accept()</code>会程序阻塞，并且读取数据时程序也会阻塞，一次只能处理一个请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerV1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"等待连接..."</span>);</div><div class="line">            <span class="comment">// 程序阻塞，等待客户端连接</span></div><div class="line">            Socket client = serverSocket.accept();</div><div class="line">            System.out.println(<span class="string">"有客户端连接服务端..."</span>);</div><div class="line">            handle(client);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Socket client)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> (InputStream inputStream = client.getInputStream();) &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            <span class="comment">// 程序阻塞，没有数据可读时就阻塞</span></div><div class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</div><div class="line">            <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"读取客户端数据："</span> + <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>优化一下，可以将处理socket连接的程序放到一个线程中处理（或者线程池）</p>
<ul>
<li>每来一个请求都需要一个线程进行处理，开销大</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerV2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"等待连接..."</span>);</div><div class="line">            <span class="comment">// 程序阻塞，等待客户端连接</span></div><div class="line">            <span class="keyword">final</span> Socket client = serverSocket.accept();</div><div class="line">            System.out.println(<span class="string">"有客户端连接服务端..."</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 使用线程处理请求</span></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    handle(client);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Socket client)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> (InputStream inputStream = client.getInputStream();) &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            <span class="comment">// 程序阻塞，没有数据可读时就阻塞</span></div><div class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</div><div class="line">            <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"读取客户端数据："</span> + <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用流程图示</p>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/bio_流程.png" alt="图片"></p>
<h2 id="同步非阻塞IO（NIO）"><a href="#同步非阻塞IO（NIO）" class="headerlink" title="同步非阻塞IO（NIO）"></a>同步非阻塞IO（NIO）</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>同步非阻塞IO是指用户进程主动发起，不需要等待内核IO操作彻底完成就立即返回用户空间的IO操作，在IO操作过程中，发起IO请求的用户进程或线程处理非阻塞的状态。</p>
</li>
<li><p>非阻塞和阻塞的区别是</p>
<ul>
<li>阻塞是指用户进程或线程一直在等待，不能做别的事情</li>
<li>非阻塞是指用户进程或线程获得内核返回的状态值就返回自己的空间，可以去做其他的事情。</li>
</ul>
</li>
</ul>
<h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><ul>
<li>与阻塞IO模型不同的是，当数据未准备好的时候，kernel会先返回给进程A一个消息，告诉它还没准备好，这时进程A就会搞一个while循环，<strong>一直在这里不停的问kernel数据好了没（在每次询问之间进程A还是可以做一点其他事情的，而不是像阻塞IO那样啥也不能做，就一直等着）</strong>，直到数据准备好了，然后开始阻塞住，等待数据拷贝完成，kernel再回复进程A，进程A就可以处理数据了。</li>
<li><strong>这里的非阻塞是指发出要数据的请求后，kernel直接会给出一个数据还没准备好的答复，而不像阻塞IO那样，一个回音都没有。但是后面数据准备好了，在数据拷贝的过程中，进程A依然是阻塞的，要等到kernel拷贝好数据后给出答复再进行数据处理。</strong></li>
</ul>
<p><img src="/assets/blog_images/io_model/nio.png" alt="图片"></p>
<h3 id="NIO代码示例"><a href="#NIO代码示例" class="headerlink" title="NIO代码示例"></a>NIO代码示例</h3><ul>
<li><p>Jdk1.4版本开始支持NIO API</p>
</li>
<li><p>基础的NIO代码如下</p>
<ul>
<li>channelList用于存储socket连接，每次有连接进来就放到集合中，然后遍历集合进行数据的读取</li>
<li>遍历channelList会有性能的损耗，下面多路复用就是解决这个问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerV1</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</div><div class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></div><div class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        System.out.println(<span class="string">"服务启动成功"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// 非阻塞模式accept方法不会阻塞</span></div><div class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层会调用linux内核的accept函数</span></div><div class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</div><div class="line">            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"客户端连接成功"</span>);</div><div class="line">                <span class="comment">// 设置SocketChannel为非阻塞</span></div><div class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                channelList.add(socketChannel);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 遍历连接进行数据的读取</span></div><div class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                SocketChannel sc = iterator.next();</div><div class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">256</span>);</div><div class="line">                <span class="keyword">int</span> read = sc.read(byteBuffer);</div><div class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</div><div class="line">                    System.out.println(<span class="string">"读取客户端数据: "</span> + <span class="keyword">new</span> String(byteBuffer.array(), StandardCharsets.UTF_8));</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</div><div class="line">                    iterator.remove();</div><div class="line">                    System.out.println(<span class="string">"客户端断开连接"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><ul>
<li>为了提高性能，操作系统引入一种新的系统调用，专门用于查询IO文件描述符的就绪状态，通过该系统调用，一个用户进程可以监听多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程，用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。<ul>
<li>通俗理解就是<ul>
<li><strong>多路是指</strong>： 多个业务方（句柄）并发下来的 IO </li>
<li><strong>复用是指</strong>：复用一个后台处理程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="时序图-2"><a href="#时序图-2" class="headerlink" title="时序图"></a>时序图</h3><ul>
<li><p>select</p>
<p><img src="/Users/lawlite/Library/Application Support/typora-user-images/image-20220703155615706.png" alt="image-20220703155615706"></p>
</li>
<li><p>epoll</p>
<p>  <img src="/assets/blog_images/io_model/image-20220619221532446.png" alt="image-20220619221532446"></p>
</li>
</ul>
<h3 id="IO多路复用代码示例"><a href="#IO多路复用代码示例" class="headerlink" title="IO多路复用代码示例"></a>IO多路复用代码示例</h3><ul>
<li><p>代码流程解析</p>
<p><img src="/assets/blog_images/io_model/image-20220529225247909.png" alt="image-20220529225247909"></p>
</li>
<li><p>只处理真正有数据收发的socketchannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerV2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</div><div class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></div><div class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 打开Selector处理Channel，也就是使用epoll</span></div><div class="line">        Selector selector = Selector.open();</div><div class="line">        <span class="comment">// 把ServerSocketChannel注册到Selector上</span></div><div class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">        System.out.println(<span class="string">"服务启动成功"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></div><div class="line">            selector.select();</div><div class="line"></div><div class="line">            <span class="comment">// 获取selector中注册的全部时间的SelectKey实例</span></div><div class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</div><div class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                SelectionKey selectionKey = iterator.next();</div><div class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</div><div class="line">                    <span class="comment">// 如果是OP_ACCEPT事件，则进行连接和事件注册</span></div><div class="line">                    ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</div><div class="line">                    SocketChannel socketChannel = server.accept();</div><div class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                    <span class="comment">// 客户端SocketChannel同样注册到Selector中，服务端监听读事件</span></div><div class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</div><div class="line">                    System.out.println(<span class="string">"客户端连接成功"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</div><div class="line">                    <span class="comment">// 如果是OP_READ事件，则进行数据读取和打印</span></div><div class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</div><div class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">256</span>);</div><div class="line">                    <span class="keyword">int</span> len = socketChannel.read(byteBuffer);</div><div class="line">                    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</div><div class="line">                        System.out.println(<span class="string">"读取客户端数据: "</span> + <span class="keyword">new</span> String(byteBuffer.array(), StandardCharsets.UTF_8));</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</div><div class="line">                        <span class="comment">// 客户端断开连接，从连接中移除。</span></div><div class="line">                        System.out.println(<span class="string">"客户端断开连接"</span>);</div><div class="line">                        socketChannel.close();</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 从事件集合中删除本次处理的key, 防止限次select重复处理</span></div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><ul>
<li><p>API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span></div></pre></td></tr></table></figure>
<ul>
<li>nfds: 最大文件描述符+1</li>
<li>rset: 读事件集合/位图</li>
<li>wset: 写事件集合/位图</li>
<li>eset: 异常事件集合/位图</li>
<li>time: 等待I/o的最长时间，NULL表示一直等待</li>
</ul>
</li>
<li><p>代码示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读事件集合，使用位图表示，默认大小是1024，所以最多处理1024个连接，可修改</span></div><div class="line">fd_set rset;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</div><div class="line">	...变量声明、socket端口绑定等省略</div><div class="line">  <span class="comment">// 准备5个文件描述符接收客户端的连接</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">		<span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</div><div class="line">		addrlen = <span class="keyword">sizeof</span>(client);</div><div class="line">		fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</div><div class="line">		<span class="keyword">if</span>(fds[i] &gt; max)&#123;</div><div class="line">      max = fds[i];</div><div class="line">    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">    <span class="comment">// rset会被内核修改，每次循环进行需要重新初始化</span></div><div class="line">		FD_ZERO(&amp;rset);</div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</div><div class="line">			FD_SET(fds[i],&amp;rset);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">    <span class="comment">// select函数，传入读事件集合进行监听处理，如果没有数据到来会阻塞，如果有数据来，会对fd对应的位图置位</span></div><div class="line">		select(max+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</div><div class="line">    <span class="comment">// 遍历所有的fd,判断哪个fd被置位了，表示有数据到来，进行数据读取</span></div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			<span class="keyword">if</span>(FD_ISSET(fds[i],&amp;rset))&#123;</div><div class="line">				<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</div><div class="line">				read(fds[i], buffer, MAXBUF);</div><div class="line">				<span class="built_in">puts</span>(buffer);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>缺点：</p>
<ul>
<li>fd_set默认是1024个；</li>
<li>fd_set rset不可重用，每次循环需要重新初始化；</li>
<li>fd_set会从用户态copy到内核态，由内核判断fd是否有数据，虽然是整体的拷贝，但还是存在用户态到内核态的切换；</li>
<li>数据到来后，fd_set rset需要再次遍历一遍来判断哪个fd有数据，需要O(n)的复杂度</li>
</ul>
</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><ul>
<li><p>API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>fds: pollfd接口体集合</li>
<li>nfds: 监听多少个文件描述符</li>
<li>timeout：超时时间</li>
</ul>
<p>pollfd结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></div><div class="line">  <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></div><div class="line">  <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></div><div class="line">  <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>代码示例</p>
<ul>
<li>poll和select类似，只是没有采用位图，而是声明了一个结构体pollfd</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</div><div class="line">	...变量声明、socket端口绑定等省略</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfds</span>[5];</span></div><div class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">		<span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</div><div class="line">		addrlen = <span class="keyword">sizeof</span>(client);</div><div class="line">    <span class="comment">// 文件描述符为连接的文件</span></div><div class="line">		pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</div><div class="line">    <span class="comment">// 接收读事件</span></div><div class="line">		pollfds[i].events = POLLIN;</div><div class="line">	&#125;</div><div class="line">	sleep(<span class="number">1</span>);</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">    <span class="comment">// poll函数，当有数据到来时，会将对应fd的revents置位POLLIN</span></div><div class="line">		poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">			<span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</div><div class="line">        <span class="comment">// 恢复到之前的状态，然后读取数据</span></div><div class="line">				pollfds[i].revents = <span class="number">0</span>;</div><div class="line">				<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</div><div class="line">				read(pollfds[i].fd, buffer, MAXBUF);</div><div class="line">				<span class="built_in">puts</span>(buffer);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>poll解决了select的1、2两个缺点，后面两个缺点还是存在，</p>
</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><ul>
<li><p>epoll API主要提供三个系统调用</p>
<ul>
<li><p>int epoll_create(int size);</p>
<p>创建一个 epoll 对象</p>
<ul>
<li><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
</li>
<li><p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
</li>
<li><p>Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与epoll的使用方式密切相关：</p>
<ul>
<li><strong>wq：</strong> 等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。</li>
<li><strong>rbr：</strong> 一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一棵红黑树。通过这棵树来管理用户进程下添加进来的所有 socket 连接。</li>
<li><strong>rdllist：</strong> 就绪的描述符的链表。当有的连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历整棵树。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></div><div class="line">　　...</div><div class="line">    <span class="comment">/*等待队列链表*/</span></div><div class="line">    <span class="keyword">wait_queue_head_t</span> wq;</div><div class="line">　　<span class="comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，</span></div><div class="line">　　也就是这个epoll监控的事件*/</div><div class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></div><div class="line">　　<span class="comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span></div><div class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></div><div class="line">　　...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 我们在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。
</code></pre><ul>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>向 epoll 对象中添加要管理的连接</p>
<ul>
<li><p>epfd：是epoll_create()的返回值。</p>
</li>
<li><p>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</p>
</li>
<li><p>fd：是需要监听的fd（文件描述符）</p>
</li>
<li><p>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct epoll_event &#123;</div><div class="line"> __uint32_t events; /* Epoll events */</div><div class="line"> epoll_data_t data; /* User data variable */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//events可以是以下几个宏的集合：<br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
</li>
<li><p>如果增加 socket 句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；</p>
<ul>
<li>软中断：是执行中断指令产生的，无外部施加中断请求信号，因此中断的发生不是随机的而是程序安排好的，比如编程异常（1/0），系统调用就是典型的软中断。</li>
<li>硬中断：是由与系统相连的外部设备产生的，比如磁盘、网卡、键盘、鼠标、时钟等，因此具有随机性和突发性，每个设备都有它自己的IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动（中断处理程序）上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
<p> 等待其管理的连接上的 IO 事件，就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；</p>
<ul>
<li>等待epfd上的io事件，最多返回maxevents个事件。</li>
<li>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</li>
<li>参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。</li>
<li>该函数返回需要处理的事件数目，如返回0表示已超时。</li>
</ul>
</li>
</ul>
<ul>
<li><p>调用图示</p>
<p><img src="/assets/blog_images/io_model/epoll工作流程.png" alt="img"></p>
</li>
<li><p>epoll的两种触发模式</p>
<ul>
<li><p>LT（水平触发）模式下，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</p>
</li>
<li><p>ET（边缘触发）模式下，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。</p>
<p><img src="/assets/blog_images/io_model/epoll_et_lt.png" alt="图片"></p>
<ul>
<li>如果采用 EPOLLLT 模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边缘触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</li>
</ul>
</li>
<li><p>代码示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</div><div class="line">	...变量声明、socket端口绑定等省略</div><div class="line">	<span class="keyword">int</span> epfd, epct, i;</div><div class="line">	<span class="comment">// 定义epoll事件</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></div><div class="line">	<span class="comment">// 定义epoll事件集合</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[20];</span></div><div class="line">	<span class="built_in">memset</span>(events, <span class="number">0</span>, <span class="number">20</span> * <span class="keyword">sizeof</span>(struct epoll_event));</div><div class="line">	<span class="comment">// 创建epoll的fd，红黑树</span></div><div class="line">	epfd = epoll_create(<span class="number">1</span>);</div><div class="line">	</div><div class="line">	event.data.fd = serverFd;</div><div class="line">	<span class="comment">// 填充事件类型，监听读事件</span></div><div class="line">	event.events = EPOLLIN;</div><div class="line">	<span class="comment">// 把serverFd(监听FD)和事件添加到红黑树上</span></div><div class="line">	epoll_ctl(epfd, EPOLL_CTL_ADD, serverFd, &amp;event);</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">		<span class="comment">// 等待时间到来，阻塞模式，同时监听20个事件，返回就绪的事件个数</span></div><div class="line">		epct = epoll_wait(epfd, events, <span class="number">20</span>, <span class="number">-1</span>);</div><div class="line">		<span class="comment">// 根据epoll返回的值查询事件</span></div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; epct; i++) &#123;</div><div class="line">				<span class="keyword">if</span> (events[i].data.fd == serverFd) &#123;</div><div class="line">					<span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(clientAddr);</div><div class="line">					clientFd = accept(events[i].data.fd, (struct sockaddr *)&amp;clientAddr, &amp;length);</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"new fd=%d ip %s\n"</span>, clientFd, inet_ntoa(clientAddr.sin_addr));</div><div class="line">					event.data.fd = clientFd;</div><div class="line">					event.events = EPOLLIN | EPOLLET;</div><div class="line">					<span class="comment">// event.events = EPOLLIN;</span></div><div class="line">					epoll_ctl(epfd, EPOLL_CTL_ADD, clientFd, &amp;event);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"new data arrive\n"</span>);</div><div class="line">					<span class="comment">// 如果不是serverFd, 就是clientFd的读事件</span></div><div class="line">					<span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFLEN);</div><div class="line">					rlen = read(events[i].data.fd, buf, BUFLEN);</div><div class="line">					<span class="keyword">if</span> (rlen &lt;= <span class="number">0</span>) &#123;</div><div class="line">						<span class="comment">// 客户端断开</span></div><div class="line">						<span class="built_in">printf</span>(<span class="string">"fd %d disconnected\n"</span>, events[i].data.fd);</div><div class="line">						close(events[i].data.fd);</div><div class="line">						epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;event);</div><div class="line">						<span class="keyword">continue</span>;</div><div class="line">					&#125;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"fd: %d data: %s\n"</span>, events[i].data.fd, buf);</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>解决了select和poll的缺点</p>
</li>
</ul>
<h4 id="三种对比"><a href="#三种对比" class="headerlink" title="三种对比"></a>三种对比</h4><table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>底层数据结构</td>
<td>数组存储文件描述符</td>
<td>链表存储文件描述符</td>
<td>红黑树存储监控的文件描述符，双链表存储就绪的文件描述符</td>
</tr>
<tr>
<td>如何从fd数据中获取就绪的fd</td>
<td>遍历fd_set</td>
<td>遍历链表</td>
<td>回调</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>获得就绪的文件描述符需要遍历fd数组，O(n)</td>
<td>获得就绪的文件描述符需要遍历fd链表，O(n)</td>
<td>当有就绪事件时，系统注册的回调函数就会被调用，将就绪的fd放入到就绪链表中。O(1)</td>
</tr>
<tr>
<td>FD数据拷贝</td>
<td>每次调用select，需要将fd数据从用户空间拷贝到内核空间</td>
<td>每次调用poll，需要将fd数据从用户空间拷贝到内核空间</td>
<td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间</td>
</tr>
<tr>
<td>最大连接数</td>
<td>有限制，一般为1024</td>
<td>无限制</td>
<td>无限制</td>
</tr>
</tbody>
</table>
<h3 id="Reactor设计模式"><a href="#Reactor设计模式" class="headerlink" title="Reactor设计模式"></a>Reactor设计模式</h3><ul>
<li><p>wikipedia的描述</p>
<blockquote>
<p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.</p>
</blockquote>
</li>
<li><p>Reactor模式是处理并发I/O常见的一种模式，用于同步I/O，其中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I/O事件到来或是准备就绪，多路复用器将返回并将相应<code>I/O</code>事件分发到对应的处理器中。</p>
<ul>
<li>Reactor是一种事件驱动机制，和普通函数调用不同的是应用程序不是主动的调用某个API来完成处理，恰恰相反的是Reactor逆置了事件处理流程，应用程序需提供相应的接口并注册到Reactor上，如果有相应的事件发生，Reactor将主动调用应用程序注册的接口（回调函数）</li>
</ul>
<p><img src="/assets/blog_images/io_model/reactor.png" alt="img"></p>
</li>
</ul>
<h4 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h4><ul>
<li>Handle 句柄；用来标识socket连接或是打开文件；</li>
<li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）</li>
<li>Event Handler：事件处理接口</li>
<li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</li>
<li>Reactor：反应器，定义一个接口，实现以下功能：  1）供应用程序注册和删除关注的事件句柄；  2）运行事件循环；  3）有就绪事件到来时，分发事件到之前注册的回调函数上处理；</li>
</ul>
<p><img src="/assets/blog_images/io_model/reactor_class.png" alt="Reactor"></p>
<h4 id="Reactor时序图"><a href="#Reactor时序图" class="headerlink" title="Reactor时序图"></a>Reactor时序图</h4><ul>
<li><p>应用启动，将关注的事件handle注册到Reactor中；</p>
</li>
<li><p>调用Reactor，进入无限事件循环，等待注册的事件到来；</p>
</li>
<li><p>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</p>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/reactor_时序.png" alt="seq_Reactor"></p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><ul>
<li><p>单线程的<code>Reactor</code>模式对于客户端的所有请求使用一个专门的线程去处理，这个线程无限循环地监听是否有客户端的请求抵达，一旦收到客户端的请求，就将其分发给响应处理程序进行处理。</p>
<ul>
<li><code>Reactor</code> 负责响应IO事件，当检测到一个新的事件会将其发送给相应的处理程序去处理。</li>
<li><code>Handler</code> 负责处理非阻塞的行为，标识系统管理的资源，同时将处理程序与事件绑定。</li>
</ul>
</li>
<li><p>单线程的Reactor与NIO流程类似，只是将消息相关处理独立到<code>Handler</code>中。虽然NIO中一个线程可以支持所有的IO处理，但瓶颈也是显而易见的。如果某个客户端多次进行请求时在<code>Handler</code>中的处理速度较慢，那么后续的客户端请求都会被积压，导致响应变慢。所以需要引入Reactor多线程模型。</p>
<p><img src="/assets/blog_images/io_model/image-20220712001415441.png" alt="image-20220712001415441"></p>
</li>
</ul>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul>
<li>考虑到工作线程的复用，可以将工作线程设计线程池。将处理器的执行放入线程池，并使用多线程处理业务逻辑，Reactor仍然是单个线程。</li>
<li>Reactor读线程模型是将Handler中的IO操作和非IO操作分开，操作IO的线程称为IO线程，非IO操作的线程称为工作线程。客户端的请求会被直接丢到线程池中，因此不会发生堵塞。</li>
<li>多线程的Reactor的特点是一个Reactor线程和多个处理线程，将业务处理即<code>process</code>交给线程池进行了分离，Reactor线程只关注事件分发和字节的发送和读取。需要注意的是，实际的发送和读取还是由Reactor来处理。当在高并发环境下，有可能会出现连接来不及接收。<ul>
<li>当用户进一步增加时Reactor也会出现瓶颈，因为Reactor既要处理IO操作请求也要响应连接请求。为了分担Reactor的负担，可以引入主从Reactor模型。</li>
</ul>
</li>
</ul>
<p>​    <img src="/assets/blog_images/io_model/image-20220703160015365.png" alt="image-20220703160015365"></p>
<h4 id="主从多线程"><a href="#主从多线程" class="headerlink" title="主从多线程"></a>主从多线程</h4><ul>
<li>对于多个CPU的机器，为了充分利用系统资源会将Reactor拆分为两部分。<ul>
<li>Main Reactor 负责监听连接，将<code>accept</code>连接交给<code>Sub Reactor</code>处理，主Reactor用于响应连接请求。</li>
<li>Sub Reactor 处理<code>accept</code>连接，从Reactor用于处理IO操作请求。</li>
</ul>
</li>
<li>主从Reactor的特点是使用 一个<code>Selector</code>池，通常有一个主<code>Reactor</code>用于处理接收连接事件，多个从<code>Reactor</code>处理实际的IO。整体来看，分工合作，分而治之，非常高效。</li>
<li>为什么需要单独拆分一个Reactor来处理监听呢？<ul>
<li>因为像TCP这样需要经过3次握手才能建立连接，这个建立的过程也是需要消耗时间和资源的，单独拆分一个Reactor来处理，可以提高性能。</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/image-20220703160033862.png" alt="image-20220703160033862"></p>
<h5 id="netty模型图"><a href="#netty模型图" class="headerlink" title="netty模型图"></a>netty模型图</h5><ul>
<li>Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，<ul>
<li>BossGroup 中的线程专门负责和客户端建立连接，</li>
<li>WorkerGroup中的线程专门负责处理连接上的读写。</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/netty模型图.png" alt="image-20210605210313208"></p>
<h4 id="工作流程（Epoll为例）"><a href="#工作流程（Epoll为例）" class="headerlink" title="工作流程（Epoll为例）"></a>工作流程（Epoll为例）</h4><ol>
<li><p>主线程向<code>epoll</code>内核事件表中注册<code>socket</code>上的读就绪事件</p>
</li>
<li><p>主线程调用<code>epoll_wait</code>等待<code>socket</code>上有数据可读</p>
</li>
<li><p>当<code>socket</code>上有数据可读时，<code>epoll_wait</code>通知主线程，主线程将<code>socket</code>可读事件放入请求队列。</p>
</li>
<li><p>休眠在请求队列上的某个工作线程被唤醒，从<code>socket</code>中读取数据并处理客户端请求，然后向<code>epoll</code>内核事件表中注册该<code>socket</code>上的写就绪事件。</p>
</li>
<li><p>主线程调用<code>epoll_wait</code>等待<code>socket</code>可写</p>
</li>
<li><p>当<code>socket</code>可写时<code>epoll_wait</code>通知主线程，主线程将<code>socket</code>可写事件放入请求队列。</p>
</li>
<li><p>休眠在请求队列上的某个工作线程被唤醒，向<code>socket</code>上写入服务器处理客户请求的结果。</p>
<p><img src="/assets/blog_images/io_model/epoll_工作流程.png" alt="img"></p>
</li>
</ol>
<h4 id="Reactor优缺点"><a href="#Reactor优缺点" class="headerlink" title="Reactor优缺点"></a>Reactor优缺点</h4><ul>
<li><p>优点</p>
<ul>
<li><p>响应快，不为单个同步时间所阻塞，虽然Reactor自身依然是同步的。</p>
</li>
<li><p>编程相对简单，可以最大程度的避免复杂的多线程以及同步问题和多线程以及多进程的切换开销。</p>
</li>
<li><p>可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源。</p>
</li>
<li><p>可复用性， Reactor框架本身与具体事件处理逻辑无关，具有很高的复用性。</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>Reactor增加了一定的复杂性，因而具有一定的门槛，并且不易于调试。</p>
</li>
<li><p>Reactor模式需要底层的<code>Synchronous Event Demultiplexer</code>支持，比如Java中的Selector支持，操作系统的select系统调用支持。</p>
</li>
<li><p>Reactor模式在IO读写数据时会在同一线程中实现，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间。例如在大文件传输时，IO操作会影响其他客户端的时间，因而对于这种操作，使用传统的<code>Thread-Per-Connection</code>或许是一个更好的选择，或者采用<code>Proactor</code>模式。</p>
</li>
</ul>
</li>
</ul>
<h5 id="单线程Reactor代码示例"><a href="#单线程Reactor代码示例" class="headerlink" title="单线程Reactor代码示例"></a>单线程Reactor代码示例</h5><ul>
<li><p>Reactor负责响应IO事件，当检测到一个新的事件会将其发送给相应的处理程序去处理</p>
<ul>
<li><p>首次连接进来，调用dispatch方法，获取到Acceptor实例处理连接</p>
</li>
<li><p>客户端发送数据，获取到BasicHandler实例进行处理数据</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Reactor(<span class="number">8080</span>));</div><div class="line">			th.setName(<span class="string">"Reactor"</span>);</div><div class="line">			th.start();</div><div class="line">			th.join();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 选择器，通知通道就绪的事件</span></div><div class="line">	<span class="keyword">final</span> Selector selector;</div><div class="line">	<span class="keyword">final</span> ServerSocketChannel serverSocket;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		selector = Selector.open();</div><div class="line">		serverSocket = ServerSocketChannel.open();</div><div class="line">		<span class="comment">// 绑定端口</span></div><div class="line">		serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">		<span class="comment">// 设置成非阻塞模式</span></div><div class="line">		serverSocket.configureBlocking(<span class="keyword">false</span>);</div><div class="line">		<span class="comment">// 注册并关注一个 IO 事件</span></div><div class="line">		SelectionKey sk = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">		<span class="comment">// 关联事件的处理程序</span></div><div class="line">		sk.attach(<span class="keyword">new</span> Acceptor());</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"Listening on port "</span> + port);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 死循环</span></div><div class="line">			<span class="keyword">while</span> (!Thread.interrupted()) &#123;</div><div class="line">				<span class="comment">// 阻塞，直到有通道事件就绪</span></div><div class="line">				selector.select();</div><div class="line">				<span class="comment">// 拿到就绪通道 SelectionKey 的集合</span></div><div class="line">				Set&lt;SelectionKey&gt; selected = selector.selectedKeys();</div><div class="line">				Iterator&lt;SelectionKey&gt; it = selected.iterator();</div><div class="line">				<span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">					SelectionKey skTmp = it.next();</div><div class="line">					<span class="comment">// 分发</span></div><div class="line">					dispatch(skTmp);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// 清空就绪通道的 key</span></div><div class="line">				selected.clear();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			ex.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey k)</span> </span>&#123;</div><div class="line">		<span class="comment">// 获取key关联的处理器</span></div><div class="line">		Runnable r = (Runnable) (k.attachment());</div><div class="line">		<span class="comment">// 执行处理</span></div><div class="line">		<span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">			r.run();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 处理连接建立事件</div><div class="line">	 */</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">// 接收连接，非阻塞模式下，没有连接直接返回 null</span></div><div class="line">				SocketChannel sc = serverSocket.accept();</div><div class="line">				<span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</div><div class="line">					<span class="comment">// 把提示发到界面</span></div><div class="line">					sc.write(ByteBuffer.wrap(<span class="string">"Implementation of Reactor Design Partten \r\nreactor&gt; "</span>.getBytes()));</div><div class="line">					System.out.println(<span class="string">"Accept and handler - "</span> + sc.socket().getLocalSocketAddress());</div><div class="line">					<span class="keyword">new</span> BasicHandler(selector, sc); <span class="comment">// 单线程处理连接</span></div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">				ex.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="信号量驱动"><a href="#信号量驱动" class="headerlink" title="信号量驱动"></a>信号量驱动</h2><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并安装一个信号处理函数，进程继续运行并不阻塞。</p>
</li>
<li><p>当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。</p>
<ul>
<li><strong>比喻：</strong>鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以做别的事情。</li>
</ul>
</li>
</ul>
<h3 id="时序图-3"><a href="#时序图-3" class="headerlink" title="时序图"></a>时序图</h3><ul>
<li>开启套接字信号驱动IO功能</li>
<li>系统调用Sigaction执行信号处理函数（非阻塞，立刻返回）</li>
<li>数据就绪，生成Sigio信号，通过信号回调通知应用来读取数据<ul>
<li>此种IO方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据</li>
</ul>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/信号量驱动_时序.png" alt="图片"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>信号驱动式IO对于TCP套接字产生的作用不大。因为该信号在TCP套接字中产生的过于频繁。以下条件均会导致对一个TCP套接字产生SIGIO信号：<ul>
<li>监听套接字上某个连接请求已经完成；</li>
<li>某个断连请求已经发起；</li>
<li>某个断连请求已经完成；</li>
<li>某个连接之半已经关闭；</li>
<li>数据到达套接字；</li>
<li>数据已经从套接字发送走；</li>
<li>发生某个异步错误。</li>
</ul>
</li>
<li>UDP套接字中，只有以下两个条件会产生SIGIO信号：<ul>
<li>数据报到达套接字；</li>
<li>套接字上发生异步错误。</li>
</ul>
</li>
</ul>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>异步IO模型的基本流程是：</p>
<ul>
<li>用户线程通过系统调用向内核注册某个IO操作</li>
<li><p>内核在整个IO操作（包括数据准备、数据复制）完成后通知用户程序，用户执行后续的业务操作</p>
</li>
<li><p>在整个内核的数据准备过程中，用户程序都不需要阻塞</p>
</li>
</ul>
</li>
<li><p>与NIO不同，当进行读写操作时，只需要直接调用API的read或write方法即可，这两种方法均为异步的，对于读操作而言，当有流可读时，操作系统会将可读的流传入read方法的缓冲区，对于写操作而言，当操作系统将write方法传入的流写入完毕是，操作系统会主动通知应用程序</p>
<ul>
<li>read和write方法都是异步的，完成后主动调用回调函数。</li>
</ul>
</li>
</ul>
<h3 id="时序图-4"><a href="#时序图-4" class="headerlink" title="时序图"></a>时序图</h3><p><img src="/assets/blog_images/io_model/aio_时序.png" alt="图片"></p>
<h3 id="异步IO代码示例"><a href="#异步IO代码示例" class="headerlink" title="异步IO代码示例"></a>异步IO代码示例</h3><table>
<thead>
<tr>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket</td>
<td>SocketChannel</td>
<td>AsynchronousSocketChannel</td>
</tr>
<tr>
<td>ServerSocket</td>
<td>ServerSocketChannel</td>
<td>AsynchronousServerSocketChannel</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</div><div class="line">    <span class="keyword">static</span> String CHARSET = <span class="string">"utf-8"</span>; <span class="comment">//默认编码</span></div><div class="line">    <span class="keyword">static</span> CharsetDecoder decoder = Charset.forName(CHARSET).newDecoder(); <span class="comment">//解码</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> port;</div><div class="line">    AsynchronousServerSocketChannel serverChannel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AioServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//打开一个服务通道</span></div><div class="line">        <span class="comment">//绑定服务端口</span></div><div class="line">        <span class="keyword">this</span>.serverChannel = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">100</span>);</div><div class="line">        <span class="keyword">this</span>.serverChannel.accept(<span class="keyword">this</span>, <span class="keyword">new</span> AcceptHandler());</div><div class="line"></div><div class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"运行中..."</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">2000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        t.start();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(AsynchronousSocketChannel client)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            client.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"正在启动服务..."</span>);</div><div class="line">            AioServer server = <span class="keyword">new</span> AioServer(PORT);</div><div class="line">            server.listen();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>AcceptHandler</p>
<ul>
<li>接收请求处理，如果有连接请求进来，读取客户端数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">AioServer</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel client, AioServer attachment)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"远程地址："</span> + client.getRemoteAddress());</div><div class="line">            <span class="comment">//tcp各项参数</span></div><div class="line">            client.setOption(StandardSocketOptions.TCP_NODELAY, <span class="keyword">true</span>);</div><div class="line">            client.setOption(StandardSocketOptions.SO_SNDBUF, <span class="number">1024</span>);</div><div class="line">            client.setOption(StandardSocketOptions.SO_RCVBUF, <span class="number">1024</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (client.isOpen()) &#123;</div><div class="line">                System.out.println(<span class="string">"client.isOpen："</span> + client.getRemoteAddress());</div><div class="line">                <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</div><div class="line">                buffer.clear();</div><div class="line">                client.read(buffer, client, <span class="keyword">new</span> ReadHandler(buffer));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            attachment.serverChannel.accept(attachment, <span class="keyword">this</span>);<span class="comment">// 监听新的请求，递归调用。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AioServer attachment)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            exc.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            attachment.serverChannel.accept(attachment, <span class="keyword">this</span>);<span class="comment">// 监听新的请求，递归调用。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ReadHandler</p>
<ul>
<li>读取客户端数据，处理请求完之后相应客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">AsynchronousSocketChannel</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> ByteBuffer buffer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buffer = buffer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, AsynchronousSocketChannel attachment)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;<span class="comment">// 客户端关闭了连接</span></div><div class="line">                AioServer.close(attachment);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"空数据"</span>); <span class="comment">// 处理空数据</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 读取请求，处理客户端发送的数据</span></div><div class="line">                buffer.flip();</div><div class="line">                CharBuffer charBuffer = AioServer.decoder.decode(buffer);</div><div class="line">                System.out.println(charBuffer.toString()); <span class="comment">//接收请求</span></div><div class="line"></div><div class="line">                <span class="comment">//响应操作，服务器响应结果</span></div><div class="line">                buffer.clear();</div><div class="line">                String res = <span class="string">"HTTP/1.1 200 OK"</span> + <span class="string">"\r\n\r\n"</span> + <span class="string">"hellworld"</span>;</div><div class="line">                buffer = ByteBuffer.wrap(res.getBytes());</div><div class="line">                attachment.write(buffer, attachment, <span class="keyword">new</span> WriteHandler(buffer));<span class="comment">//Response：响应。</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AsynchronousSocketChannel attachment)</span> </span>&#123;</div><div class="line">        exc.printStackTrace();</div><div class="line">        AioServer.close(attachment);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>WriteHandler</p>
<ul>
<li>处理完相应，服务端关闭连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">AsynchronousSocketChannel</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> ByteBuffer buffer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteHandler</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.buffer = buffer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, AsynchronousSocketChannel attachment)</span> </span>&#123;</div><div class="line">        buffer.clear();</div><div class="line">        AioServer.close(attachment);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AsynchronousSocketChannel attachment)</span> </span>&#123;</div><div class="line">        exc.printStackTrace();</div><div class="line">        AioServer.close(attachment);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Proactor设计模式"><a href="#Proactor设计模式" class="headerlink" title="Proactor设计模式"></a>Proactor设计模式</h3><h4 id="Proactor模式结构"><a href="#Proactor模式结构" class="headerlink" title="Proactor模式结构"></a>Proactor模式结构</h4><ul>
<li>Handle 句柄；用来标识socket连接或是打开文件；</li>
<li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li>
<li>Asynchronous Operation：异步操作</li>
<li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用</li>
<li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li>
<li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li>
<li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</li>
</ul>
<p><img src="/assets/blog_images/io_model/proactor_class.png" alt="Proactor"></p>
<h4 id="Proactor时序图"><a href="#Proactor时序图" class="headerlink" title="Proactor时序图"></a>Proactor时序图</h4><ul>
<li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</li>
<li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；</li>
<li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；</li>
<li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</li>
</ul>
<p><img src="/assets/blog_images/io_model/proactor_时序png.png" alt="seq_Proactor"></p>
<h4 id="和Reactor差别"><a href="#和Reactor差别" class="headerlink" title="和Reactor差别"></a>和Reactor差别</h4><h5 id="主动和被动"><a href="#主动和被动" class="headerlink" title="主动和被动"></a>主动和被动</h5><p>以主动写为例： </p>
<ul>
<li><p>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑； </p>
</li>
<li><p>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</p>
</li>
</ul>
<p>可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；<br>Proactor直接调用异步读写操作，调用完后立刻返回；</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul>
<li><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</p>
</li>
<li><p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</p>
</li>
</ul>
<h2 id="5种IO模型比较"><a href="#5种IO模型比较" class="headerlink" title="5种IO模型比较"></a>5种IO模型比较</h2><p><img src="/assets/blog_images/io_model/IO模型比较.png" alt="wxmp"></p>
<h1 id="IO模型使用的例子"><a href="#IO模型使用的例子" class="headerlink" title="IO模型使用的例子"></a>IO模型使用的例子</h1><h2 id="Redis-6-0之前-gt-单线程Reactor"><a href="#Redis-6-0之前-gt-单线程Reactor" class="headerlink" title="Redis(6.0之前) =&gt; 单线程Reactor"></a>Redis(6.0之前) =&gt; 单线程Reactor</h2><ul>
<li><p>Redis6.0之前都是单线程，Redis6.0以及之后的版本引入多线程</p>
</li>
<li><p>这里单线程指的是网络请求模块使用一个线程来处理，即一个线程处理所有网络请求，其他模块仍用了多个线程，也就是单线程Reactor模式，为什么之前都是单线程官方给出的解释是：</p>
<blockquote>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p>
</blockquote>
<p>意思CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。</p>
<p><img src="/assets/blog_images/io_model/redis_1.png" alt="图片"></p>
</li>
<li><p>client: 客户端对象</p>
<ul>
<li>客户端通过 <strong>socket</strong> 与服务端建立网络通道然后发送请求命令，服务端执行请求的命令并回复。Redis 使用结构体 client 存储客户端的所有相关信息，包括但不限于封装的套接字连接 – *conn，当前选择的读入缓冲区 – querybuf，写出缓冲区 – buf，写出数据链表 – reply等。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>aeApiPoll</strong>：I/O 多路复用 API，是基于 epoll_wait/select/kevent 等系统调用的封装，监听等待读写事件触发，然后处理，它是事件循环（Event Loop）中的核心函数，是事件驱动得以运行的基础。</li>
<li><strong>acceptTcpHandler</strong>：连接应答处理器，底层使用系统调用 accept 接受来自客户端的新连接，并为新连接注册绑定命令读取处理器，以备后续处理新的客户端 TCP 连接</li>
<li><strong>readQueryFromClient</strong>：命令读取处理器，解析并执行客户端的请求命令。</li>
<li><strong>beforeSleep</strong>：事件循环中进入 aeApiPoll 等待事件到来之前会执行的函数，其中包含一些日常的任务，比如把 client-&gt;buf 或者 client-&gt;reply （后面会解释为什么这里需要两个缓冲区）中的响应写回到客户端，持久化 AOF 缓冲区的数据到磁盘等，相对应的还有一个 afterSleep 函数，在 aeApiPoll 之后执行。</li>
<li><strong>sendReplyToClient</strong>：命令回复处理器，当一次事件循环之后写出缓冲区中还有数据残留，则这个处理器会被注册绑定到相应的连接上，等连接触发写就绪事件时，它会将写出缓冲区剩余的数据回写到客户端。</li>
</ul>
<p><img src="/assets/blog_images/io_model/redis_单线程.png" alt="图片"></p>
<h2 id="Nginx-gt-master-worker多进程模型"><a href="#Nginx-gt-master-worker多进程模型" class="headerlink" title="Nginx =&gt; master-worker多进程模型"></a>Nginx =&gt; master-worker多进程模型</h2><ul>
<li><p>master进程先建好需要监听的socket后，再fork出多个worker进程，这样每个worker进程都可以去接收这个socket。</p>
</li>
<li><p>当一个client连接到来时，所有的worker进程都会收到通知，但只有一个可以accept成功。</p>
<ul>
<li>这里Nginx提供了一个共享锁accept_mutex，虽然所有的worker都会收到通知，但只有一个进程抢到锁，其它失败，成功的worker进程接收请求。</li>
<li>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接。</li>
</ul>
</li>
<li><p>当运行过程中，如果worker进程出现异常，master会对worker进行重启。重启时会先启动新的worker进程，然后向老的worker发送信号。新的worker启动后，就开始接收新的请求；而老的worker在收到信号后不再接收请求，将当前进程中所有未处理完的请求处理完成后，再退出。</p>
</li>
<li><p>nginx是基于事件模型，适合于IO密集型任务，比如反向代理，IO模型采用epoll实现</p>
</li>
</ul>
<p><img src="/assets/blog_images/io_model/nginx_master_worker.png" alt="图片"></p>
<h2 id="Mysql-gt-一个连接一个线程或线程池"><a href="#Mysql-gt-一个连接一个线程或线程池" class="headerlink" title="Mysql =&gt; 一个连接一个线程或线程池"></a>Mysql =&gt; 一个连接一个线程或线程池</h2><ul>
<li><p>在 MySQL 5.6出现以前，MySQL 处理连接的方式是 <code>One-Connection-Per-Thread</code>,即对于每一个数据库连接，MySQL-Server都会创建一个独立的线程服务，请求结束后，销毁线程。</p>
<ul>
<li>这种方式在高并发情况下，会<strong>导致线程的频繁创建和释放</strong>。</li>
</ul>
</li>
<li><p>对于 <code>One-Thread-Per-Connection</code> 方式，一个线程对应一个连接，<code>Thread-Pool</code> 实现方式中，线程处理的最小单位是statement(语句)，一个线程可以处理多个连接的请求。这样，在保证充分利用硬件资源情况下(合理设置线程池大小)，可以避免瞬间连接数暴增导致的服务器抖动。</p>
</li>
<li><p>MySQL-Server 同时支持3种连接管理方式，包括<code>No-Threads</code>，<code>One-Thread-Per-Connection</code> 和 <code>Pool-Threads</code>。</p>
<ol>
<li>No-Threads 表示处理连接使用主线程处理，不额外创建线程，这种方式主要用于调试；</li>
<li>One-Thread-Per-Connection 是线程池出现以前最常用的方式，为每一个连接创建一个线程服务；</li>
<li>Pool-Threads 则是本文所讨论的线程池方式。Mysql-Server通过一组函数指针来同时支持3种连接管理方式，对于特定的方式，将函数指针设置成特定的回调函数，连接管理方式通过thread_handling参数控制，代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (thread_handling &lt;= SCHEDULER_ONE_THREAD_PER_CONNECTION)   </div><div class="line">   one_thread_per_connection_scheduler(thread_scheduler,&amp;max_connections, &amp;connection_count);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (thread_handling == SCHEDULER_NO_THREADS)</div><div class="line">     one_thread_scheduler(thread_scheduler);</div><div class="line"><span class="keyword">else</span>                                 </div><div class="line">    pool_of_threads_scheduler(thread_scheduler, &amp;max_connections,&amp;connection_count);</div></pre></td></tr></table></figure>
</li>
<li><p>通过poll监听mysql端口的连接请求 收到连接后，调用accept接口，创建通信socket</p>
</li>
<li><p>mysql线程池实现框架</p>
<ul>
<li>每一个绿色的方框代表一个group，group数目由thread_pool_size参数决定。</li>
<li>每个group包含一个优先队列和普通队列，包含一个listener线程和若干个工作线程，listener线程和worker线程可以动态转换，worker线程数目由工作负载决定，同时受到thread_pool_oversubscribe设置影响。</li>
<li>此外，整个线程池有一个timer线程监控group，防止group“停滞”。</li>
</ul>
<p><img src="/assets/blog_images/io_model/mysql_线程框架.png" alt="图片"></p>
</li>
<li><p>连接池与线程池</p>
<ul>
<li>连接池通常实现在 Client 端，是指应用(客户端)创建预先创建一定的连接，利用这些连接服务于客户端所有的DB请求。如果某一个时刻，空闲的连接数小于DB的请求数，则需要将请求排队，等待空闲连接处理。通过连接池可以复用连接，避免连接的频繁创建和释放，从而减少请求的平均响应时间，并且在请求繁忙时，通过请求排队，可以缓冲应用对DB的冲击。</li>
<li>线程池实现在server端，通过创建一定数量的线程服务DB请求，相对于 <code>one-conection-per-thread</code> 的一个线程服务一个连接的方式，线程池服务的最小单位是语句，即一个线程可以对应多个活跃的连接。通过线程池，可以将 server 端的服务线程数控制在一定的范围，减少了系统资源的竞争和线程上下文切换带来的消耗，同时也避免出现高连接数导致的高并发问题。</li>
<li>如下图：每个web-server端维护了3个连接的连接池，对于连接池的每个连接实际不是独占db-server的一个worker，而是可能与其他连接共享。这里假设db-server只有3个group，每个group只有一个worker，每个worker处理了2个连接的请求。</li>
</ul>
<p><img src="/assets/blog_images/io_model/mysql_连接池和线程池.png" alt="图片"></p>
</li>
<li><p>mysql为什么使用连接池而不使用IO多路复用，网上有一些解答：</p>
<ul>
<li><a href="https://developer.aliyun.com/article/866904" target="_blank" rel="external">https://developer.aliyun.com/article/866904</a></li>
</ul>
</li>
</ul>
<h2 id="Memcache-》-单listener-固定worker线程"><a href="#Memcache-》-单listener-固定worker线程" class="headerlink" title="Memcache =》 单listener+固定worker线程"></a>Memcache =》 单listener+固定worker线程</h2><ul>
<li>memcached不同于Redis的单进程单线程，是采用多线程的工作方式。</li>
<li>有一个主线程，同时维护了一个线程池（工作线程）。worker thread工作线程和main thread主线程之间主要通过pipe来进行通信。</li>
</ul>
<p><img src="/assets/blog_images/io_model/memcache网络模型.png" alt="img"></p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ul>
<li>在服务端有一个线程(AccpectThread)，该线程负责处理客户端建立连接建立，并在连接建立后将该连接放入到一个队列(AcceptedQueue)。</li>
<li>紧接着线程(SelectThread)负责从队列取出连接进行处理，只要IO操作准备就绪(可读、可写)，该连接会被扔到工作线程中进行处理。</li>
<li>类似主从Reactor</li>
</ul>
<p><img src="/assets/blog_images/io_model/zookeeper.png" alt="在这里插入图片描述"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/O9E6ceTWVLGSarbbHR0qqA" target="_blank" rel="external">https://mp.weixin.qq.com/s/O9E6ceTWVLGSarbbHR0qqA</a></li>
<li><a href="https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></li>
<li><a href="https://mp.weixin.qq.com/s/-d8E56sBa7X-6_20vQJ45A" target="_blank" rel="external">https://mp.weixin.qq.com/s/-d8E56sBa7X-6_20vQJ45A</a></li>
<li><a href="https://blog.csdn.net/stromcruise/article/details/117606997" target="_blank" rel="external">https://blog.csdn.net/stromcruise/article/details/117606997</a></li>
<li><a href="https://mp.weixin.qq.com/s/mKJrOMo8c1IYOZSvY4Rp1A" target="_blank" rel="external">https://mp.weixin.qq.com/s/mKJrOMo8c1IYOZSvY4Rp1A</a></li>
</ul>


		
      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>谢谢你请我吃糖果<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/alipay.jpg">
                      <span class="reward-type">支付宝</span>
                    </div>
                    
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/weixin.png">
                      <span class="reward-type">微信</span>
                    </div>
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
<!-- 版权申明开始  -->

<div> 
  <ul class="post-copyright" style="
    margin: 0em 0em 0em 0em;
    padding: 0.5em 1em;
    border-left: 3px solid #ff1700;
    background-color: #f9f9f9;
    list-style: none;
    font-size: 14px;
">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Lawlite
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://lawlite.me/2022/08/27/高并发网络线程模型/" title="高并发网络线程模型">http://lawlite.me/2022/08/27/高并发网络线程模型/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png"></a> 。转载请注明出处！
    </li>
  </ul>
</div>

<!-- 版权声明结束 -->
      
    </div>

    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">io</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="http://bshare.optimix.asia/barCode?site=weixin&url=http://lawlite.cn/2022/08/27/高并发网络线程模型/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2022/03/27/R树索引/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">R树索引</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>






  
    <div class="duoshuo"></div>
  






<section class="duoshuo" id="comments">
<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8yODEwMy80Njc2">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</section>



<section class="duoshuo" id="comments">
<!-- gittalk安装代码 -->
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="http://cdn.bootcss.com/blueimp-md5/1.1.0/js/md5.js"></script>
<script type="text/javascript">
	var gitalk = new Gitalk({
	clientID: 'fbcad63a6d3d94c1baa5',
	clientSecret: 'a04089dca239e20cad16e25aeb5c2171628a73fc',
	repo: 'blog_gitalk_comments',
	owner: 'lawlite19',
	admin: ['lawlite19'],
	id: md5(window.location.pathname),
	distractionFreeMode: false
        })
        gitalk.render('gitalk-container')           
</script>
</section>


<!-- 网易云跟帖 -->


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2022 Lawlite
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv">
  总访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}])</script><script src="/./main.234bc0.js"></script><script>!function(){var e=function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)};e("/slider.885efe.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: "none",
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath:  [ ["$", "$"] ],
        displayMath: [ ["$$","$$"] ],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],
        ignoreClass:"comment-content"
    },
    "HTML-CSS": {
        availableFonts: ["STIX","TeX"],
        showMathMenu: false
    }
});
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?...">
</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Github</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Python</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">PyTorch</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DeepLearning</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">机器学习</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">爬虫</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">RNN</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">LSTM</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">GRU</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">R</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">可视化</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Tensorflow</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">翻墙</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Paper阅读记录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Cudnn</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ModelCompression</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">论文记录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">图像分割</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">ObjectDetection</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">GPU</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Torch</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">阿里云</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Style transfer</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Keras</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">io</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://blog.csdn.net/u013082989" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>My CSDN</a>
            </li>
          
            <li class="search-li">
              <a href="http://lawlite.cn/archives/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>归档</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">程序猿👨🏻‍💻</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>